const express = require("express");
const { ChunkExtractor } = require("@loadable/server");
const path = require("path");
const fs = require("fs");
const webpack = require("webpack");
const React = require("react");
const ReactDOMServer = require("react-dom/server");
const { default: App } = require("../src/App");
const { StaticRouter, matchPath } = require("react-router-dom");
const { default: createStore } = require("../src/store");
const { Provider } = require("react-redux");
const PostRouter = require("./routes/posts.routes");
const { fetchPosts } = require("../src/store/slices/post.slice");
const { default: routes } = require("../src/routes");
const { default: ErrorPage } = require("../src/pages/ErrorPage");

const PORT = process.env.PORT || 4000;
const isDev = process.env.NODE_ENV === "development";

const app = express();
// ❗ Only disable caching for HTML responses (SSR)
app.use((req, res, next) => {
  if (!req.url.startsWith("/public")) {
    res.set("Cache-Control", "no-store");
  }
  next();
});

app.use(
  "/public",
  express.static(path.resolve(__dirname, "public"), {
    maxAge: "1y", // Cache for 1 year
    immutable: true, // File will not change (safe for hashed assets), /public file will be cached
  })
);

app.use("/api/posts", PostRouter);

// in express@v5, "*" is not considered valid anymore, thats why used regex /^\/.*/
app.get(/^\/.*/, async (req, res, next) => {
  try {
    // This is the stats file generated by webpack loadable plugin
    const statsFile = path.resolve(__dirname, "public/loadable-stats.json");
    // We create an extractor from the statsFile
    const extractor = new ChunkExtractor({ statsFile });

    let promises = [];
    const store = createStore();

    let matched = false;
    routes.forEach((route) => {
      const match = matchPath(route.path, req.path);

      if (match && route.loadData) {
        matched = true;
        promises.push(route.loadData(store, match.params));
      }
    });
    await Promise.all(promises);
    const preloadedState = store?.getState();

    const htmlFileStr = fs.readFileSync(
      path.resolve(__dirname, "public/index.html"),
      "utf8"
    );

    // Wrap your application using "collectChunks"
    const jsx = extractor.collectChunks(
      <Provider store={store}>
        <StaticRouter location={req.url}>
          <App />
        </StaticRouter>
      </Provider>
    );
    const appHtml = ReactDOMServer.renderToString(jsx);

    // You can now collect your script tags
    const scriptTags = extractor.getScriptTags(); // or extractor.getScriptElements();
    // You can also collect your "preload/prefetch" links
    const linkTags = extractor.getLinkTags(); // or extractor.getLinkElements();
    // And you can even collect your style tags (if you use "mini-css-extract-plugin")
    const styleTags = extractor.getStyleTags(); // or extractor.getStyleElements();

    // Inject serverTime into HTML as a global variable
    const finalHtmlStr = htmlFileStr
      .replace(`<div id="root"></div>`, `<div id="root">${appHtml}</div>`)
      .replace(
        `</body>`,
        `${scriptTags}
          ${linkTags}
          ${styleTags}
          <script>window.__INITIAL_STATE__ = ${JSON.stringify(
            preloadedState
          )};</script></body>`
      );

    if (!matched) {
      res.status(404);
    }
    res.setHeader('Content-Type', 'text/html');
    res.send(finalHtmlStr);
  } catch (err) {
    console.error("SSR rendering failed:", err);
    const errorHTML = ReactDOMServer.renderToString(
      <ErrorPage message="Server Error: Failed to render page." />
    );

    res.status(500).send(`
      <!DOCTYPE html>
      <html>
        <head><title>Server Error</title></head>
        <body>${errorHTML}</body>
      </html>
    `);
  }
});

app.listen(PORT, () => {
  console.log(`Server is running on ${PORT}`);
});
